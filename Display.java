public class Display {
    // TODO: if implementing color slider, change this to three separate values standing for rgb
    private static int color;
    private static int r; 
    private static int g;
    private static int b;
    // light represents a unit vector (norm = 1)
    private static Point light;
    private static double phi;
    private static double sinPhi;
    // from 0 to 10
    private static double luminance;
    private static boolean showBoundary;

    private static Point persp = TerrainGUI.persp;
    
    // Gets light element based on cross product of two vectors and then dot product the persp
    // The two vectors are v0 = p1-p0 and v1 = p2-p1
    // Returns double from luminance to 1 inclusive
    public static double getLight(Point p0, Point p1, Point p2) {
        // normal to v0 and v1 from cross product
        double v0x = p1.subX(p0);
        double v0y = p1.subY(p0);
        double v0z = p1.subZ(p0);
        double v1x = p2.subX(p1);
        double v1y = p2.subY(p1);
        double v1z = p2.subZ(p1);
        
        // v0 x v1 = normal vector to v0 and v1 
        double normX = v0y * v1z - v0z * v1y;
        double normY = v0z * v1x - v0x * v1z;
        double normZ = v0x * v1y - v0y * v1x;
        
        // dot product
        double dot = (normX * light.getX() + normY * light.getY() + normZ * light.getZ());
        // normalized, from -1 to 1
        dot /= Math.sqrt(normX * normX + normY * normY + normZ * normZ);
        // from 0 to 1
        dot = (dot+1)/2;
        // from luminance to 1
        return luminance + (1-luminance) * dot;
    }

    // Sets the minimum liminance to view map
    public static void setLuminance(double terLum) {
        luminance = terLum;
    }

    // TODO: change this method when implementing color slider
    // Sets the color gradient for map 
    public static void setColor(int terColor) {
        color = terColor;
    }

    // Sets light direction
    public static void setLight(Point terLight) {
        light = terLight;
    }

    // Sets phi
    public static void setPhi(double terPhi) {
        phi = terPhi;
        sinPhi = Math.sin(phi/180*Math.PI);
    }

    // Sets whether to show boundary
    public static void setShowBoundary(boolean terShow) {
        showBoundary = terShow;
    }

    // TODO: Adds 3D-look effect: Points farther away from persp will "attract" to the z-axis 
    // (x-coord will shrink by a factor that decreases from 1 as distance increases)
    public static void compress(Point[][] mat, Point persp) {
        
    }

    // Pen color is dependent on z-coord and map (matrix) size
    // TODO: if implementing color slider, change this
    public static void setPenColor(double z, int size, double light) {
        // from 0 to 1
        // TODO: try to get as close to having the full range (all z vals spread over 0 to 1)
        // Perhaps use the initalialized Points for help (will be set as fields)
        double zVar = ((z+sinPhi*size)/(2*sinPhi*size));
        if (zVar > 1) zVar = 1;
        if (zVar < 0) zVar = 0;

        // gray
        if (color == 0) StdDraw.setPenColor((int)(light * (zVar * 185 + 70)), (int)(light * (zVar * 185 + 70)), (int)(light * (zVar * 185 + 70)));
        // red
        else if (color == 1) StdDraw.setPenColor((int)(light * (zVar * 100 + 155)), (int)(light * 50), (int)(light * 70));
        // green
        else if (color == 2) StdDraw.setPenColor(0, (int)(light * (135 * zVar + 120)), (int)(light * (100 * zVar)));
        // blue
        else StdDraw.setPenColor((int)(light * 50), (int)(light * (zVar * 100 + 100)), (int)(light * 255));
    }

    // TODO: modify to display light
    // Draws points given in mat
    public static void displayPoints(Point[][] mat) {
        int len = mat.length;
        int shift = (len-1)/2;
        // add color based on z-coord later
        for (int i = 0; i < len; i++) {
            for (int j = 0; j < len; j++) {
                Point p = mat[i][j];
                double x = p.getX();
                double z = p.getZ();
                setPenColor(z-sinPhi*(j-shift), shift, 1);
                StdDraw.point(x, z);
            }
        }
    }

    // Draws mesh generated by mat
    public static void displayMesh(Point[][] mat) {
        int len = mat.length;
        int shift = (len-1)/2;
        // triangle strips method (prevents overlap in drawing)
        for (int i = 0; i < len-1; i++) {
            for (int j = 0; j < len-1; j++) {
                Point p = mat[i][j];
                Point pUp = mat[i][j+1];
                Point pRight = mat[i+1][j];
                setPenColor(p.getZ() - sinPhi*(j-shift), shift, getLight(p, pUp, pRight));
                // draws triangle
                StdDraw.polygon(new double[] {p.getX(), pUp.getX(), pRight.getX()}, new double[] {p.getZ(), pUp.getZ(), pRight.getZ()});
            }
        }        
        // connects last row and col
        Point prev = mat[0][len-1];
        double prevX = prev.getX();
        double prevZ = prev.getZ();
        for (int i = 1; i < len; i++) {
            Point p = mat[i][len-1];
            double pX = p.getX();
            double pZ = p.getZ();
            setPenColor(prevZ - sinPhi*(len-1-shift), shift, 1);
            StdDraw.line(pX, pZ, prevX, prevZ);
            prevX = pX;
            prevZ = pZ;
        }
        for (int j = len-2; j >= 0; j--) {
            Point p = mat[len-1][j];
            double pX = p.getX();
            double pZ = p.getZ();
            setPenColor(prevZ - sinPhi*(j-shift), shift, 1);
            StdDraw.line(pX, pZ, prevX, prevZ);
            prevX = pX;
            prevZ = pZ;
        }
    }

    // TODO: Add persp generation (affects where the map starts and ends generating - related to i and j)
    // Draws terrain generated by mat and persp
    public static void displayTerrain(Point[][] mat) {
        int len = mat.length;
        int shift = (len-1)/2;

        // TODO: Boundary function?
        // TODO: Perhaps do something about points below boundary

        Point prev0;
        Point prev1;
        double sumZ;
        for (int i = 0; i < len-1; i++) {
            prev0 = mat[i][len-1];
            prev1 = mat[i+1][len-1];
            sumZ = prev0.getZ() + prev1.getZ();
            for (int j = len-2; j >= 0; j--) {
                Point curr0 = mat[i][j];
                Point curr1 = mat[i+1][j];
                sumZ += curr0.getZ();
                // fill first triangle (prev0, prev1, curr0)
                setPenColor(sumZ/3 - sinPhi*(j-shift), shift, getLight(prev0, prev1, curr0));
                StdDraw.filledPolygon(new double[] {prev0.getX(), prev1.getX(), curr0.getX()}, new double[] {prev0.getZ(), prev1.getZ(), curr0.getZ()});
                sumZ -= prev0.getZ() - curr1.getZ();
                // fill second triangle (prev1, curr0, curr1)
                setPenColor(sumZ/3 - sinPhi*(j-shift), shift, getLight(curr0, prev1, curr1));
                StdDraw.filledPolygon(new double[] {prev1.getX(), curr0.getX(), curr1.getX()}, new double[] {prev1.getZ(), curr0.getZ(), curr1.getZ()});
                sumZ -= prev1.getZ();
                // set prev0 to curr0 and prev1 to curr1
                prev0 = curr0;
                prev1 = curr1;
            }
        }
    }

    // Draws the boundary (outline) of map
    public static void displayBoundary(Point[][] mat) {

    }
}
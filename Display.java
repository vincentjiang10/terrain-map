public class Display {
    private static int color = -1;
    
    // Sets the color gradient for map
    public static void setColor(int c) {
        color = c;
    }

    // Pen color is dependent on z-coord and map (matrix) size
    // Precond: color is from 0 inclusive to 3 inclusive
    public static void setPenColor(double z, int size, double light) {
        // from 0 to 1
        double zVar = ((z+0.3*size)/(0.6*size));
        if (color == 0) StdDraw.setPenColor((int)(light * (zVar * 255/2 +70)), (int)(light * (zVar * 255/2 + 70)), (int)(light * (zVar * 255/2 + 70)));
        else if (color == 1) StdDraw.setPenColor((int)(light * (zVar * 100 + 155)), (int)(light * 50), (int)(light * 70));
        else if (color == 2) StdDraw.setPenColor(0, (int)(light * (135 * zVar + 120)), (int)(light * (100 * zVar)));
        else StdDraw.setPenColor((int)(light * 50), (int)(light * zVar * 255), (int)(light *255));
    }

    // Draws points given in mat
    public static void displayPoints(Point[][] mat) {
        int len = mat.length;
        // add color based on z-coord later
        for (int i = 0; i < len; i++) {
            for (int j = 0; j < len; j++) {
                Point p = mat[i][j];
                double x = p.getX();
                double z = p.getZ();
                double light = 1;
                setPenColor(z, (len-1)/2, light);
                // later, add darker shade if normal away from persp 
                // (the more away from persp - dot product < 0), apply lower coeff reduction to rgb
                StdDraw.point(x, z);
            }
        }
    }

    // Draws mesh generated by mat
    public static void displayMesh(Point[][] mat) {
        
    }

    // Draws terrain generated by mat and persp
    public static void displayTerrain(Point[][] mat, Point persp) {

    }
}
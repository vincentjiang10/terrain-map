public class Display {
    private static int color;
    private static Point persp;
    
    // Sets the color gradient for map (called from TerrainMap.java)
    public static void setColor(int c) {
        color = c;
    }

    // Sets the perspective (called from TerrainMap.java)
    public static void setPerp(Point p) {
        persp = p;
    }

    // TODO: add "far away look" affect. Points farther away from persp will "attract" to the z-axis 
    // (x-coord will shrink by a factor that decreases from 1 as distance increases)

    // Pen color is dependent on z-coord and map (matrix) size
    // Precond: color is from 0 inclusive to 3 inclusive
    public static void setPenColor(double z, int size, double light) {
        // from 0 to 1
        double zVar = ((z+0.3*size)/(0.6*size));
        if (zVar > 1) zVar = 1;
        if (zVar < 0) zVar = 0;
        if (color == 0) StdDraw.setPenColor((int)(light * (zVar * 255/2 +70)), (int)(light * (zVar * 255/2 + 70)), (int)(light * (zVar * 255/2 + 70)));
        else if (color == 1) StdDraw.setPenColor((int)(light * (zVar * 100 + 155)), (int)(light * 50), (int)(light * 70));
        else if (color == 2) StdDraw.setPenColor(0, (int)(light * (135 * zVar + 120)), (int)(light * (100 * zVar)));
        else StdDraw.setPenColor((int)(light * 50), (int)(light * zVar * 255), (int)(light *255));
    }

    // Draws points given in mat
    public static void displayPoints(Point[][] mat) {
        int len = mat.length;
        int shift = (len-1)/2;
        // add color based on z-coord later
        for (int i = 0; i < len; i++) {
            for (int j = 0; j < len; j++) {
                Point p = mat[i][j];
                double x = p.getX();
                double z = p.getZ();
                setPenColor(z-0.3*(j-shift), shift, 1);
                // later, add darker shade if normal away from persp 
                // (the more away from persp - dot product < 0), apply lower coeff reduction to rgb
                StdDraw.point(x, z);
            }
        }
    }

    // Draws mesh generated by mat
    public static void displayMesh(Point[][] mat) {
        int len = mat.length;
        int shift = (len-1)/2;
        double light = 1;
        // triangle strips method (prevents overlap in drawing)
        for (int i = 0; i < len-1; i++) {
            for (int j = 0; j < len-1; j++) {
                Point p = mat[i][j];
                Point pUp = mat[i][j+1];
                Point pRight = mat[i+1][j];
                double pX = p.getX();
                double pZ = p.getZ();
                double pUpX = pUp.getX();
                double pUpZ = pUp.getZ();
                double pRightX = pRight.getX();
                double pRightZ = pRight.getZ();
                setPenColor(pZ-0.3*(j-shift), shift, light);
                StdDraw.line(pX, pZ, pUpX, pUpZ);
                StdDraw.line(pX, pZ, pRightX, pRightZ);
                StdDraw.line(pRightX, pRightZ, pUpX, pUpZ);
            }
        }        
        // connects last row and col
        Point prev = mat[0][len-1];
        double prevX = prev.getX();
        double prevZ = prev.getZ();
        for (int i = 1; i < len; i++) {
            Point p = mat[i][len-1];
            double pX = p.getX();
            double pZ = p.getZ();
            setPenColor(prevZ-0.3*(len-1-shift), shift, light);
            StdDraw.line(pX, pZ, prevX, prevZ);
            prevX = pX;
            prevZ = pZ;
        }
        for (int j = len-2; j >= 0; j--) {
            Point p = mat[len-1][j];
            double pX = p.getX();
            double pZ = p.getZ();
            setPenColor(prevZ-0.3*(j-shift), shift, light);
            StdDraw.line(pX, pZ, prevX, prevZ);
            prevX = pX;
            prevZ = pZ;
        }
    }

    // Draws terrain generated by mat and persp
    public static void displayTerrain(Point[][] mat, Point persp) {

    }
}